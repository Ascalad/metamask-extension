diff --git a/src/buildtime/modulesData.js b/src/buildtime/modulesData.js
index 567053c8380fc636522a2f44fed7ac91e9202cbd..132fde044ef7cf183426983ec4d6fd805ef6a4f8 100644
--- a/src/buildtime/modulesData.js
+++ b/src/buildtime/modulesData.js
@@ -1,11 +1,11 @@
-const diag = require('./diagnostics.js')
-const { WebpackError } = require('webpack')
+const diag = require('./diagnostics.js');
+const { WebpackError } = require('webpack');
 
 /** @import {Module, NormalModule, ExternalModule} from 'webpack' */
 /** @import {InspectableWebpackModule} from './policyGenerator.js' */
 
 // TODO: move into an enum file along with the other
-const JAVASCRIPT_MODULE_TYPE_DYNAMIC = 'javascript/dynamic'
+const JAVASCRIPT_MODULE_TYPE_DYNAMIC = 'javascript/dynamic';
 
 /**
  * @remarks
@@ -24,8 +24,8 @@ const isIgnoredModule = (m) => {
     m.type === JAVASCRIPT_MODULE_TYPE_DYNAMIC &&
       // @ts-expect-error BAD TYPES
       m.identifierStr?.startsWith('ignored')
-  )
-}
+  );
+};
 
 /**
  * Checks if a module is a context module.
@@ -35,7 +35,7 @@ const isIgnoredModule = (m) => {
  * @returns {boolean} - Returns true if the module is a context module,
  *   otherwise false.
  */
-const isContextModule = (m, moduleClass) => moduleClass === 'ContextModule'
+const isContextModule = (m, moduleClass) => moduleClass === 'ContextModule';
 
 /**
  * Identifies an asset that webpack includes in dist by default without setting
@@ -49,7 +49,7 @@ const isAmbientAsset = (m) =>
   'resource' in m &&
   'loaders' in m &&
   Array.isArray(m.loaders) &&
-  m.loaders.length === 0
+  m.loaders.length === 0;
 
 /**
  * @param {Module} m
@@ -59,7 +59,7 @@ const isAmbientAsset = (m) =>
 const isExternalModule = (m, moduleClass) =>
   ['ExternalModule'].includes(moduleClass) &&
   'externalType' in m &&
-  m.externalType !== undefined
+  m.externalType !== undefined;
 /**
  * @param {Module} m
  * @param {string} moduleClass
@@ -68,7 +68,7 @@ const isExternalModule = (m, moduleClass) =>
 const isInspectableModule = (m, moduleClass) =>
   'userRequest' in m ||
   m.type?.startsWith('javascript') ||
-  isExternalModule(m, moduleClass)
+  isExternalModule(m, moduleClass);
 
 /**
  * @typedef {{
@@ -103,26 +103,26 @@ exports.analyzeModules = ({
    *
    * @type {{ path: string; moduleId: string | number }[]}
    */
-  const knownPaths = []
+  const knownPaths = [];
   /**
    * Array of module ids that are unenforceable by policy.
    *
    * @type {(string | number)[]}
    */
-  const unenforceableModuleIds = []
+  const unenforceableModuleIds = [];
   /**
    * Array of module ids that are context modules and need to be double-wrapped.
    *
    * @type {{ moduleId: string | number; context: string }[]}
    */
-  const contextModules = []
+  const contextModules = [];
 
   /**
    * An array of modules deemed fit for inspecting for policy
    *
    * @type {InspectableWebpackModule[]}
    */
-  const inspectable = []
+  const inspectable = [];
 
   /**
    * A record of module ids that are externals and need to be enforced as
@@ -130,22 +130,22 @@ exports.analyzeModules = ({
    *
    * @type {Record<string | number, string>}
    */
-  const externals = {}
+  const externals = {};
 
   /**
    * @param {IdentifiedModule} arg
    * @returns
    */
   const processModule = ({ module, moduleId }) => {
-    const moduleClass = Object.getPrototypeOf(module).constructor.name
+    const moduleClass = Object.getPrototypeOf(module).constructor.name;
 
     if (moduleId === null) {
       diag.rawDebug(
         2,
         `LavaMoatPlugin: module ${module.identifier()} has no moduleId, cannot cover it with policy.`
-      )
-      diag.rawDebug(4, { module })
-      return
+      );
+      diag.rawDebug(4, { module });
+      return;
     }
 
     // ==================================================
@@ -155,21 +155,21 @@ exports.analyzeModules = ({
     // TODO: refactor to move random hardening of the build somewhere it's easier to track.
     if (
       isAmbientAsset(module) &&
-      module.resource.includes('node_modules') // FIXME: would be better to use canonicalName lookup and match with root
+      module.resourceResolveData.context.issuer.includes('node_modules')
     ) {
       // add a warning about removing the asset
       mainCompilationWarnings.push(
         new WebpackError(
           `LavaMoatPlugin: the following resource was being silently emitted to the dist directory and LavaMoat has prevented it: '${module.resource}'. If you want to add this resource, explicitly define a file-loader for it in your webpack configuration.`
         )
-      )
+      );
 
       // We can't use `chunkGraph.disconnectChunkAndModule` here
       // because the require statement remains and errors out
 
       if (module.generatorOptions) {
         // generatorOptions was not present in testing, but types indicate it might be there
-        module.generatorOptions.emit = false
+        module.generatorOptions.emit = false;
       }
       if (module.generator) {
         module.generator = Object.create(module.generator, {
@@ -177,7 +177,7 @@ exports.analyzeModules = ({
             value: false,
             enumerable: true,
           },
-        })
+        });
       }
     }
 
@@ -195,37 +195,37 @@ exports.analyzeModules = ({
           // @ts-expect-error we want to see it if available
           _identifier: module?._identifier,
         },
-      })
+      });
       if (!module.context) {
         mainCompilationWarnings.push(
           new WebpackError(
             `LavaMoatPlugin: context module ${moduleId} has no context information. It cannot be allowed to work if it's reached at runtime.`
           )
-        )
+        );
       } else {
-        contextModules.push({ moduleId, context: module.context })
+        contextModules.push({ moduleId, context: module.context });
       }
     }
     if (isIgnoredModule(module)) {
-      unenforceableModuleIds.push(moduleId)
+      unenforceableModuleIds.push(moduleId);
     } else {
       if (isExternalModule(module, moduleClass)) {
-        externals[moduleId] = module.userRequest
+        externals[moduleId] = module.userRequest;
       }
       if (isInspectableModule(module, moduleClass)) {
-        inspectable.push(module)
+        inspectable.push(module);
       }
 
       // typescript is complaining about the use of `resource` here, but it's actually there.
       knownPaths.push({
         path: /** @type {any} */ (module).resource, // TODO: use actual type so that we enforce the right string being compared everywhere
         moduleId,
-      })
+      });
     }
-  }
+  };
 
   for (const { module, moduleId } of allIdentifiedModules) {
-    processModule({ module, moduleId })
+    processModule({ module, moduleId });
   }
 
   return {
@@ -234,5 +234,5 @@ exports.analyzeModules = ({
     knownPaths,
     unenforceableModuleIds,
     externals,
-  }
-}
+  };
+};
