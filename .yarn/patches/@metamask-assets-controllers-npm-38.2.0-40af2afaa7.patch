diff --git a/dist/assetsUtil.cjs b/dist/assetsUtil.cjs
index e90a1b6767bc8ac54b7a4d580035cf5db6861dca..cbda9aba94bff918ef2ff56466f0239ce053d441 100644
--- a/dist/assetsUtil.cjs
+++ b/dist/assetsUtil.cjs
@@ -2,6 +2,7 @@
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.fetchTokenContractExchangeRates = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.hasNewCollectionFields = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
@@ -221,7 +222,7 @@ async function getIpfsCIDv1AndPath(ipfsUrl) {
     const index = url.indexOf('/');
     const cid = index !== -1 ? url.substring(0, index) : url;
     const path = index !== -1 ? url.substring(index) : undefined;
-    const { CID } = await import("multiformats");
+    const { CID } = await Promise.resolve().then(() => _interopRequireWildcard(require("multiformats")));
     // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
     // because most cid v0s appear to be incompatible with IPFS subdomains
     return {
